<?php
namespace Selene\Util;

use Selene\Iterators\CustomRecursiveIterator;
use Selene\Iterators\MacroIterator;
use Selene\Iterators\MapIterator;
use Selene\Iterators\RangeIterator;
use Traversable;

class Query implements \IteratorAggregate
{
  private $data;
  private $it;

  /**
   * Sets the initial data/iterator.
   * @param array|\Iterator $src
   */
  function __construct ($src)
  {
    if ($src instanceof \Iterator)
      $this->it = $src;
    else if (is_array ($src))
      $this->data = $src;
    else throw new \InvalidArgumentException;
  }

  /**
   * @param $src
   * @return static
   */
  static function from ($src)
  {
    return new static ($src);
  }

  static function range ($from, $to, $step = 1)
  {
    return new static (new RangeIterator($from, $to, $step));
  }

  /**
   * Materializes the current iterator chain into an array.
   * @return array
   */
  function all ()
  {
    return isset($this->data) ? $this->data : iterator_to_array ($this->it);
  }

  /**
   * Appends one or more iterators to the current one and sets a new iterator that iterates over all of them.
   * @param \Iterator ...$args Iterators to append.
   * @return $this
   */
  function append ()
  {
    $a = new \AppendIterator;
    $a->append ($this->it);
    foreach (func_get_args () as $it)
      $a->append (is_array ($it) ? new \ArrayIterator ($it) : $it);
    $this->it = $a;
    return $this;
  }

  /**
   * Instantiates an outer iterator and chains it to the current iterator.
   *
   * Ex:
   * ```
   *   Query::range (1,10)->apply ('RegexIterator', '/^1/')->all ()
   * ```
   * @param string $iteratorClass The name of a class whose constructor receives an iterator as a first argument.
   * @param mixed  ...$args       Additional arguments for the external iterator's constructor.
   * @return $this
   */
  function apply ($iteratorClass)
  {
    $args     = func_get_args ();
    $args[0]  = $this->it;
    $c        = new \ReflectionClass($iteratorClass);
    $this->it = $c->newInstanceArgs ($args);
    return $this;
  }

  function cache ()
  {
    $this->it = new \CachingIterator($this->it);
  }

  /**
   * Assumes the current iterator is composed of arrays or iterators and sets a new iterator that iterates over all of
   * them.
   * @return $this
   */
  function concat ()
  {
    $a = new \AppendIterator;
    foreach ($this->it as $it)
      $a->append (is_array ($it) ? new \ArrayIterator ($it) : $it);
    $this->it = $a;
    return $this;
  }

  /**
   * Call a function for every element in the iterator.
   * @param callable $fn A callback that receives the current value and key; it can, optionally, return `false` to break
   *                     the loop.
   * @return $this
   */
  function each (callable $fn)
  {
    foreach ($this->getIterator () as $k => $v)
      if ($fn ($v, $k) === false) break;
    return $this;
  }

  /**
   * Replaces each value on the current iterator by the values generated by a new iterator.
   * @param callable $fn A callback that receives the current outer iterator item's value and key and returns the
   *                     corresponding inner Traversable or array.
   * @return $this
   */
  function expand (callable $fn)
  {
    $this->it = new MacroIterator($this->it, $fn);
    return $this;
  }

  /**
   * (PHP 5 &gt;= 5.0.0)<br/>
   * Retrieve an external iterator
   * @link http://php.net/manual/en/iteratoraggregate.getiterator.php
   * @return Traversable An instance of an object implementing <b>Iterator</b> or
   * <b>Traversable</b>
   */
  public function getIterator ()
  {
    if (isset($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    return $this->it;
  }

  /**
   * Replaces values by the corresponding keys.
   * @return $this
   */
  function keys ()
  {
    $this->it = new MapIterator($this->it, function ($v, $k) { return $k; });
    return $this;
  }

  /**
   * Transforms each input data item.
   * @param callable $fn A callback that receives a value and a key and returns the new value.<br>
   *                     It can also receive the key by reference and change it.
   *                     <p>Ex:<code>  ->map (function ($v, &$k) { $k = $k * 10; return $v * 100; })</code>
   * @return $this
   */
  function map (callable $fn)
  {
    if (isset($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    $this->it = new MapIterator($this->it, $fn);
    return $this;
  }

  /**
   * Transforms each input data item, optionally filtering it out.
   * @param callable $fn A callback that receives a value and key and returns a new value or `null` to discard it.<br>
   *                     It can also receive the key by reference and change it.
   *                     <p>Ex:<code>  ->mapAndFilter (function ($v, &$k) { $k = $k * 10; return $v > 5 ? $v * 100 :
   *                     null; })</code>
   * @return $this
   */
  function mapAndFilter (callable $fn)
  {
    if (isset($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    $this->it = new \CallbackFilterIterator (new MapIterator($this->it, $fn), function ($v) {
      return isset($v);
    });
    return $this;
  }

  /**
   * Reindexes the current data into a series of sequential integer values, thereby eliminating discontinuous keys.
   *
   * Note: this is faster than {@see reindex()} bit it materializes the data.
   * @return $this
   */
  function pack ()
  {
    $this->data = isset ($this->data) ? array_values ($this->data) : iterator_to_array ($this->it, false);
    return $this;
  }

  /**
   * Wraps a recursive iterator over the current iterator.
   * @param callable $fn A callback that receives the current node's value, key and nesting depth, and returns an
   *                     array or {@see Traversable} for the node's children or `null` if the node has no
   *                     children.
   * @return $this
   */
  function recursive (callable $fn)
  {
    $this->it = new \RecursiveIteratorIterator(new CustomRecursiveIterator($this->it, $fn));
    return $this;
  }

  /**
   * Transforms data into arrays of regular expression matches for each item.
   * @param string $regexp     The regular expression to match.
   * @param int    $preg_flags The regular expression flags. Can be a combination of: PREG_PATTERN_ORDER,
   *                           PREG_SET_ORDER, PREG_OFFSET_CAPTURE.
   * @param bool   $useKeys    When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function regex ($regexp, $preg_flags = 0, $useKeys = false)
  {
    $this->it =
      new \RegexIterator($this->it, $regexp, \RegexIterator::ALL_MATCHES, $useKeys ? \RegexIterator::USE_KEY : 0,
        $preg_flags);
    return $this;
  }

  /**
   * Transforms data by extracting the first regular expression match for each item.
   * @param string $regexp     The regular expression to match.
   * @param int    $preg_flags The regular expression flags. Can be 0 or PREG_OFFSET_CAPTURE.
   * @param bool   $useKeys    When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function regexExtract ($regexp, $preg_flags = 0, $useKeys = false)
  {
    $this->it =
      new \RegexIterator($this->it, $regexp, \RegexIterator::GET_MATCH, $useKeys ? \RegexIterator::USE_KEY : 0,
        $preg_flags);
    return $this;
  }

  /**
   * Transforms each string data item into another using a regular expression.
   * @param string $regexp      The regular expression to match.
   * @param string $replaceWith Literal content with $N placeholders, where N is the capture group index.
   * @param bool   $useKeys     When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function regexMap ($regexp, $replaceWith, $useKeys = false)
  {
    $this->it = new \RegexIterator($this->it, $regexp, \RegexIterator::REPLACE, $useKeys ? \RegexIterator::USE_KEY : 0);

    $this->it->replacement = $replaceWith;
    return $this;
  }

  /**
   * Splits each data item into arrays of strings using a regular expression.
   * @param string $regexp     The regular expression to match.
   * @param int    $preg_flags The regular expression flags. Can be a combination of: PREG_SPLIT_NO_EMPTY,
   *                           PREG_SPLIT_DELIM_CAPTURE, PREG_SPLIT_OFFSET_CAPTURE.
   * @param bool   $useKeys    When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function regexSplit ($regexp, $preg_flags = 0, $useKeys = false)
  {
    $this->it = new \RegexIterator($this->it, $regexp, \RegexIterator::SPLIT, $useKeys ? \RegexIterator::USE_KEY : 0,
      $preg_flags);
    return $this;
  }

  /**
   * Reindexes the current data into a series of sequential integer values, starting from the specified value,
   * @param int $i The new starting value for the keys sequence.
   * @return $this
   */
  function reindex ($i = 0)
  {
    $this->it = new MapIterator($this->it, function ($v, &$k) use (&$i) {
      $k = $i++;
      return $v;
    });
    return $this;
  }

  /**
   * Limits iteration to the specified range.
   * @param int $offset
   * @param int $count
   * @return $this
   */
  function slice ($offset = 0, $count = -1)
  {
    if (isset($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    $this->it = new \LimitIterator($this->it, $offset, $count);
    return $this;
  }

  /**
   * Sorts the data by its keys.
   *
   * Note: this method materializes the data.
   * @param int $flags One or more of the SORT_XXX constants.
   * @return $this
   */
  function sort ($flags)
  {
    $this->data = $this->all ();
    sort ($this->data, $flags);
    return $this;
  }

  /**
   * Filters data by a condition.
   * @param callable $fn A callback that receives the element and its key and returns `true` for the elements that
   *                     should be kept.
   * @return $this
   */
  function where (callable $fn)
  {
    if (isset($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    $this->it = new \CallbackFilterIterator($this->it, $fn);
    return $this;
  }

  /**
   * Filters data using a regular expression test.
   * @param string $regexp     The regular expression to match.
   * @param int    $preg_flags The regular expression flags. Can be 0 or PREG_OFFSET_CAPTURE.
   * @param bool   $useKeys    When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function whereMatch ($regexp, $preg_flags = 0, $useKeys = false)
  {
    $this->it = new \RegexIterator($this->it, $regexp, \RegexIterator::MATCH, $useKeys ? \RegexIterator::USE_KEY : 0,
      $preg_flags);
    return $this;
  }

}

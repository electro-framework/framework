<?php
namespace Selene\Util;

use Iterator;
use IteratorAggregate;
use Selene\Iterators\CustomRecursiveIterator;
use Selene\Iterators\LoopIterator;
use Selene\Iterators\MacroIterator;
use Selene\Iterators\MapIterator;
use Selene\Iterators\RangeIterator;
use Traversable;

class Iteration implements IteratorAggregate
{
  private static $SORT_TYPES = [
    'asort'       => 2,
    'arsort'      => 2,
    'krsort'      => 2,
    'ksort'       => 2,
    'natcasesort' => 1,
    'natsort'     => 1,
    'rsort'       => 2,
    'shuffle'     => 1,
    'sort'        => 2,
    'uasort'      => 3,
    'uksort'      => 3,
    'usort'       => 3,
  ];
  /** @var array */
  private $data;
  /** @var Iterator */
  private $it;

  /**
   * Sets the initial data/iterator.
   * @param array|Traversable $src
   */
  function __construct ($src)
  {
    if ($src instanceof Iterator)
      $this->it = $src;
    else if ($src instanceof IteratorAggregate)
      $this->it = $src->getIterator ();
    else if (is_array ($src))
      $this->data = $src;
    else throw new \InvalidArgumentException;
  }

  /**
   * @param array|Traversable $src
   * @return static
   */
  static function from ($src)
  {
    return new static ($src);
  }

  /**
   * Creates an iteration over a generated sequence of numbers.
   * @param int|float $from Starting value.
   * @param int|float $to   The (inclusive) limit. May be lower than `$from` if the `$step` is negative.
   * @param int|float $step Can be either positive or negative. If zero, an infinite sequence of constant values is
   *                        generated.
   * @return static
   */
  static function range ($from, $to, $step = 1)
  {
    return new static (new RangeIterator ($from, $to, $step));
  }

  /**
   * Concatenates the specified Traversables and iterates them in sequence.
   */
  static function sequence ()
  {
    $a = new \AppendIterator;
    foreach (func_get_args () as $it)
      $a->append (self::normalize ($it));
    return new static ($a);
  }

  /**
   * Converts the argument into an iterator.
   * @param Traversable|array $t
   * @return Iterator
   */
  private static function normalize ($t)
  {
    return $t instanceof IteratorAggregate
      ? $t->getIterator ()
      : (is_array ($t) ? new \ArrayIterator ($t) : $t);
  }

  /**
   * Materializes the current iterator chain into an array.
   * @return array
   */
  function all ()
  {
    return isset ($this->data) ? $this->data : iterator_to_array ($this->it);
  }

  /**
   * Appends one or more iterators to the current one and sets a new iterator that iterates over all of them.
   * @param Iterator ...$args Iterators to append.
   * @return $this
   */
  function append ()
  {
    $a = new \AppendIterator;
    $a->append ($this->it);
    foreach (func_get_args () as $it)
      $a->append (self::normalize ($it));
    $this->it = $a;
    return $this;
  }

  /**
   * Instantiates an outer iterator and chains it to the current iterator.
   *
   * Ex:
   * ```
   *   Query::range (1,10)->apply ('RegexIterator', '/^1/')->all ()
   * ```
   * @param string $iteratorClass The name of an iterator or iterator aggregate class whose constructor receives an
   *                              iterator as a first argument.
   * @param mixed  ...$args       Additional arguments for the external iterator's constructor.
   * @return $this
   */
  function apply ($iteratorClass)
  {
    $args     = func_get_args ();
    $args[0]  = $this->it;
    $c        = new \ReflectionClass ($iteratorClass);
    $i        = $c->newInstanceArgs ($args);
    $this->it = $i instanceof IteratorAggregate ? $i->getIterator () : $i;
    return $this;
  }

  function cache ()
  {
    $this->it = new \CachingIterator ($this->it);
  }

  /**
   * Assumes the current iterator is composed of arrays or iterators and sets a new iterator that iterates over all of
   * them.
   * @return $this
   */
  function concat ()
  {
    $a = new \AppendIterator;
    foreach ($this->it as $it)
      $a->append (self::normalize ($it));
    $this->it = $a;
    return $this;
  }

  /**
   * Drops the last `$n` elements from the iteration.
   *
   * Note: this also materializes the data and reindexes it.
   * @param int $n
   * @return $this
   */
  function drop ($n = 1)
  {
    $this->pack ();
    $this->data = array_slice ($this->data, 0, -$n);
    return $this;
  }

  /**
   * Calls a function for every element in the iterator.
   * @param callable $fn A callback that receives the current value and key; it can, optionally, return `false` to break
   *                     the loop.
   * @return $this
   */
  function each (callable $fn)
  {
    foreach ($this->getIterator () as $k => $v)   // note: can't use $this->it directly.
      if ($fn ($v, $k) === false) break;
    return $this;
  }

  /**
   * Replaces each value on the current iterator by the values generated by a new iterator.
   * @param callable $fn A callback that receives the current outer iterator item's value and key and returns the
   *                     corresponding inner Traversable or array.
   * @return $this
   */
  function expand (callable $fn)
  {
    $this->it = new MacroIterator ($this->it, $fn);
    return $this;
  }

  /**
   * (PHP 5 &gt;= 5.0.0)<br/>
   * Retrieves an external iterator. This allows instances of this class to be iterated (ex. on foreach loops).
   * @link http://php.net/manual/en/iteratoraggregate.getiterator.php
   * @return Traversable An instance of an object implementing <b>Iterator</b> or
   * <b>Traversable</b>
   */
  public function getIterator ()
  {
    if (isset ($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    return $this->it;
  }

  /**
   * Replaces values by the corresponding keys.
   * @return $this
   */
  function keys ()
  {
    $this->it = new MapIterator ($this->it, function ($v, $k) { return $k; });
    return $this;
  }

  /**
   * Repeats the iteration `$n` items.
   * <p>If `$n` > iterator count, this will have no effect.
   * @param int $n
   * @return $this
   */
  function loop ($n)
  {
    $this->it = new LoopIterator ($this->it);
    $this->it->loop ($n);
    return $this;
  }

  /**
   * Transforms each input data item.
   * @param callable $fn A callback that receives a value and a key and returns the new value.<br>
   *                     It can also receive the key by reference and change it.
   *                     <p>Ex:<code>  ->map (function ($v, &$k) { $k = $k * 10; return $v * 100; })</code>
   * @return $this
   */
  function map (callable $fn)
  {
    if (isset ($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    $this->it = new MapIterator ($this->it, $fn);
    return $this;
  }

  /**
   * Transforms each input data item, optionally filtering it out.
   * @param callable $fn A callback that receives a value and key and returns a new value or `null` to discard it.<br>
   *                     It can also receive the key by reference and change it.
   *                     <p>Ex:<code>  ->mapAndFilter (function ($v, &$k) { $k = $k * 10; return $v > 5 ? $v * 100 :
   *                     null; })</code>
   * @return $this
   */
  function mapAndFilter (callable $fn)
  {
    if (isset ($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    $this->it = new \CallbackFilterIterator (new MapIterator ($this->it, $fn), function ($v) {
      return isset ($v);
    });
    return $this;
  }

  /**
   * Iterates only the first `$n` items.
   * <p>If `$n >` iterator count or `$n < 0`, this will have no effect.
   *
   * Note: this method is not equivalent to `limit (0, $n)`, for it can handle any kind of keys.
   * @param int $n How many iterations, at most.
   * @return $this
   */
  function only ($n)
  {
    $this->it = new LoopIterator ($this->it);
    $this->it->limit ($n);
    return $this;
  }

  /**
   * Materializes and reindexes the current data into a series of sequential integer keys.
   *
   * This is useful to extract the data as a linear array with no discontinuous keys.
   *
   * This is faster than {@see reindex()} bit it materializes the data. This should usually be the last
   * operation to perform before retrieving the results.
   * @return $this
   */
  function pack ()
  {
    $this->data = isset ($this->data) ? array_values ($this->data) : iterator_to_array ($this->it, false);
    return $this;
  }

  /**
   * Wraps a recursive iterator over the current iterator.
   * @param callable $fn A callback that receives the current node's value, key and nesting depth, and returns an
   *                     array or {@see Traversable} for the node's children or `null` if the node has no
   *                     children.
   * @return $this
   */
  function recursive (callable $fn)
  {
    $this->it = new \RecursiveIteratorIterator (new CustomRecursiveIterator ($this->it, $fn));
    return $this;
  }

  /**
   * Transforms data into arrays of regular expression matches for each item.
   * @param string $regexp     The regular expression to match.
   * @param int    $preg_flags The regular expression flags. Can be a combination of: PREG_PATTERN_ORDER,
   *                           PREG_SET_ORDER, PREG_OFFSET_CAPTURE.
   * @param bool   $useKeys    When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function regex ($regexp, $preg_flags = 0, $useKeys = false)
  {
    $this->it =
      new \RegexIterator ($this->it, $regexp, \RegexIterator::ALL_MATCHES, $useKeys ? \RegexIterator::USE_KEY : 0,
        $preg_flags);
    return $this;
  }

  /**
   * Transforms data by extracting the first regular expression match for each item.
   * @param string $regexp     The regular expression to match.
   * @param int    $preg_flags The regular expression flags. Can be 0 or PREG_OFFSET_CAPTURE.
   * @param bool   $useKeys    When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function regexExtract ($regexp, $preg_flags = 0, $useKeys = false)
  {
    $this->it =
      new \RegexIterator ($this->it, $regexp, \RegexIterator::GET_MATCH, $useKeys ? \RegexIterator::USE_KEY : 0,
        $preg_flags);
    return $this;
  }

  /**
   * Transforms each string data item into another using a regular expression.
   * @param string $regexp      The regular expression to match.
   * @param string $replaceWith Literal content with $N placeholders, where N is the capture group index.
   * @param bool   $useKeys     When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function regexMap ($regexp, $replaceWith, $useKeys = false)
  {
    $this->it =
      new \RegexIterator ($this->it, $regexp, \RegexIterator::REPLACE, $useKeys ? \RegexIterator::USE_KEY : 0);

    $this->it->replacement = $replaceWith;
    return $this;
  }

  /**
   * Splits each data item into arrays of strings using a regular expression.
   * @param string $regexp     The regular expression to match.
   * @param int    $preg_flags The regular expression flags. Can be a combination of: PREG_SPLIT_NO_EMPTY,
   *                           PREG_SPLIT_DELIM_CAPTURE, PREG_SPLIT_OFFSET_CAPTURE.
   * @param bool   $useKeys    When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function regexSplit ($regexp, $preg_flags = 0, $useKeys = false)
  {
    $this->it = new \RegexIterator ($this->it, $regexp, \RegexIterator::SPLIT, $useKeys ? \RegexIterator::USE_KEY : 0,
      $preg_flags);
    return $this;
  }

  /**
   * Reindexes the current data into a series of sequential integer values, starting from the specified value,
   * @param int $i  The new starting value for the keys sequence.
   * @param int $st The incremental step.
   * @return $this
   */
  function reindex ($i = 0, $st = 1)
  {
    $this->it = new MapIterator ($this->it, function ($v, &$k) use (&$i, $st) {
      $k = $i;
      $i += $st;
      return $v;
    });
    return $this;
  }

  /**
   * Reverses the order of iteration.
   *
   * Note: this method materializes the data.
   * @param bool $preserveKeys If set to `true` numeric keys are preserved. Non-numeric keys are not affected by this
   *                           setting and will always be preserved.
   * @return $this
   */
  function reverse ($preserveKeys = false)
  {
    $this->pack ();
    $this->data = array_reverse ($this->data, $preserveKeys);
    return $this;
  }

  /**
   * Skips the first `$n` elements from the iteration.
   * @param int $n
   * @return $this
   */
  function skip ($n = 1)
  {
    return $this->slice ($n);
  }

  /**
   * Limits iteration to the specified range.
   * @param int $offset Starts at 0.
   * @param int $count  -1 = all.
   * @return $this
   */
  function slice ($offset = 0, $count = -1)
  {
    if (isset ($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    $this->it = new \LimitIterator ($this->it, $offset, $count);
    return $this;
  }

  /**
   * Sorts the data by its keys.
   *
   * Note: this method materializes the data.
   * @param string   $type  The type of sort to perform.<br>
   *                        One of:
   *                        'asort' | 'arsort' | 'krsort' | 'ksort' | 'natcasesort' | 'natsort' | 'rsort' | 'shuffle' |
   *                        'sort' | 'uasort' | 'uksort' | 'usort'
   * @param int      $flags One or more of the SORT_XXX constants.
   * @param callable $fn    Can only be specified for sort types beginning with letter `u` (ex: `usort`).
   * @return $this
   */
  function sort ($type = 'sort', $flags = SORT_REGULAR, callable $fn = null)
  {
    if (!isset (self::$SORT_TYPES[$type]))
      throw new \InvalidArgumentException ("Bad sort type: $type");
    $n          = self::$SORT_TYPES[$type];
    $this->data = $this->all ();
    switch ($n) {
      case 1:
        $type ($this->data);
        break;
      case 2:
        $type ($this->data, $flags);
        break;
      case 3:
        $type ($this->data, $fn);
        break;
    }
    return $this;
  }

  /**
   * Replaces the current data set by another.
   * @param callable $fn A callback that receives as argument an array of the current data and returns the
   *                     new data array.
   * @return $this
   */
  function swap (callable $fn)
  {
    $this->pack ();
    $this->data = $fn ($this->data);
    return $this;
  }

  /**
   * Filters data by a condition.
   * @param callable $fn A callback that receives the element and its key and returns `true` for the elements that
   *                     should be kept.
   * @return $this
   */
  function where (callable $fn)
  {
    if (isset ($this->data)) {
      $this->it = new \ArrayIterator ($this->data);
      unset ($this->data);
    }
    $this->it = new \CallbackFilterIterator ($this->it, $fn);
    return $this;
  }

  /**
   * Filters data using a regular expression test.
   * @param string $regexp     The regular expression to match.
   * @param int    $preg_flags The regular expression flags. Can be 0 or PREG_OFFSET_CAPTURE.
   * @param bool   $useKeys    When `true`, the iterated keys will be used instead of the corresponding values.
   * @return $this
   */
  function whereMatch ($regexp, $preg_flags = 0, $useKeys = false)
  {
    $this->it = new \RegexIterator ($this->it, $regexp, \RegexIterator::MATCH, $useKeys ? \RegexIterator::USE_KEY : 0,
      $preg_flags);
    return $this;
  }

}

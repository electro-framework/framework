<?php
namespace Selenia\Matisse\Components\Base;

use Selenia\Interfaces\Views\ViewInterface;
use Selenia\ViewEngine\Engines\MatisseEngine;

/**
 * A component that delegates its rendering to a separate template (either internal or external to the component),
 * which must be parsed, compiled and rendered by a view engine.
 *
 * <p>Composite components are composed of both a "light DOM" and a "shadow DOM".
 *
 * <p>The light DOM is the set of original DOM subtrees (from children or from properties) provided to the component on
 * the document by its author. It can be used to provide metadata and/or document fragments for inclusion on the shadow
 * DOM. This is the only DOM that simple (non-composite) components can access.
 *
 * <p>The shadow DOM renders the component's visual appearance and it's also called a View, which is parsed and/or
 * compiled from a template by a view engine and rendered by it.
 *
 * <p>The final rendered output is generated from combining these two DOMs.
 *
 * > <p>**Note:** components on the View can, in turn, be composite components that have their own templates and so on
 * recursively. **But** the rendered output of a composite component must be final rendered markup, it can not be again
 * a template that requires further processing.
 *
 */
class CompositeComponent extends Component
{
  /**
   * @var string
   */
  public $template = '';
  /**
   * The URL of an external template to be loaded and rendered.
   *
   * @var string
   */
  public $templateUrl = '';
  /**
   * When true, tdatabinding resolution on the component's view is unnafected by data from parent component's models or
   * from the shared document view model (which is set on {@see Context}); only the component's own view model is used.
   *
   * @var bool
   */
  protected $isolateViewModel = false;
  /**
   * The engine to be used for parsing and rendering the view if {@see render()} returns an embedded one.
   *
   * @var string
   */
  protected $viewEngineClass = MatisseEngine::class;

  /**
   * Allows subclasses to generate the view's markup dinamically.
   * If not overriden, the default behaviour is to load the view from an external file, if one is defined on
   * `$templateUrl`. If not, the content of `$template` is returned, if set, otherwise no output is generated.
   *
   * > **Note:** this returns nothing; the output is sent directly to the output buffer.
   */
  protected function render ()
  {
    if ($this->templateUrl)
      $view = $this->context->viewService->loadFromFile ($this->templateUrl);
    elseif ($this->template)
      $view = $this->context->viewService->loadFromString ($this->template, $this->viewEngineClass);
    else return null;
    $view->compile ();
    $this->setupView ($view);
    echo $view->render ();
  }

  /**
   * Allows access to the compiled view generated by the parsing process.
   * Component specific initialization can be performed here before the
   * page is rendered.
   * Override to add extra initialization.
   *
   * @param ViewInterface $view
   */
  protected function setupView (ViewInterface $view)
  {
    //override
  }

}
